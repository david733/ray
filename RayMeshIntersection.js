'use strict';

/**
 * RayMeshIntersection.js
 * Code block detecting the intersection between a set of rays and meshes. It will test each ray against ALL meshes.
 * Inputs:
 *   rays: Array of ray objects generated by the CreateRays custom block, with pre-computed ray classification and components.
 *   meshes: Flat list of Flux mesh objects. Mesh needs to have only triangular faces (can run through the Tessellate block).
 *   aabbs: Flat list of bounding boxes for the meshes. Should be a parallel list to meshes. Use BoundingBox block to generate.
 *   twosided: Boolean indicating intersection test mode. False will only check fronts of faces (one-sided intersection) and True
 *             will check both front and back of faces (two-sided intersection.) 
 * Output:
 *   Intersections: An array of intersection points for each ray, as Arrays of numbers. If there are no intersections, the array will be empty.
 *   ClosestDistances: An array of each ray's closest intersection distance, as numbers. If there are no intersections, this will be Infinity.
 */

var EPSILON = 0.000001;
var edge1 = [0,0,0];
var edge2 = [0,0,0];
var tvec = [0,0,0];
var pvec = [0,0,0];
var qvec = [0,0,0];

var tests = {};
var max = Math.max;
var abs = Math.abs;
var classify = {};

var triangleTest;

var _ = require('lodash');

function run(rays, meshes, aabbs, twosided) {
	init();
	triangleTest = twosided ? intersectTwoSidedTriangle : intersectOneSidedTriangle;

	var results = rays.map( ray => rayIntersectsMeshes(ray, meshes, aabbs) );
	
	return { "Intersections" : _.pluck(results, 'intersections'),
			"ClosestDistances": _.pluck(results, 'closestDistance')
	};
}

module.exports = {
    run: run
};

function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2]

    out[0] = ay * bz - az * by
    out[1] = az * bx - ax * bz
    out[2] = ax * by - ay * bx
    return out
}

function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}

function sub(out, a, b) {
    out[0] = a[0] - b[0]
    out[1] = a[1] - b[1]
    out[2] = a[2] - b[2]
    return out
}

function intersectOneSidedTriangle (out, pt, dir, tri) {
    sub(edge1, tri[1], tri[0]);
    sub(edge2, tri[2], tri[0]);
    
    cross(pvec, dir, edge2);
    var det = dot(edge1, pvec);
    
    if (det < EPSILON) return null;
    sub(tvec, pt, tri[0]);
    var u = dot(tvec, pvec);
    if (u < 0 || u > det) return null;
    cross(qvec, tvec, edge1);
    var v = dot(dir, qvec);
    if (v < 0 || u + v > det) return null;
    
    var t = dot(edge2, qvec) / det;
    if (t < EPSILON) return null; // this was missing from the original stack.gl implementation; prevents backtracing
    out[0] = pt[0] + t * dir[0];
    out[1] = pt[1] + t * dir[1];
    out[2] = pt[2] + t * dir[2];
    return [out, t];
}

function intersectTwoSidedTriangle (out, pt, dir, tri) {
    sub(edge1, tri[1], tri[0]);
    sub(edge2, tri[2], tri[0]);
    
    cross(pvec, dir, edge2);
    var det = dot(edge1, pvec);
    
    if (det > -EPSILON && det < EPSILON) return null;
    sub(tvec, pt, tri[0]);
    var u = dot(tvec, pvec) / det;
    if (u < 0 || u > 1) return null;
    cross(qvec, tvec, edge1);
    var v = dot(dir, qvec) / det;
    if (v < 0 || u + v > 1) return null;
    
    var t = dot(edge2, qvec) / det;
    if (t < EPSILON) return null; // this was missing from the original stack.gl implementation; prevents backtracing
    out[0] = pt[0] + t * dir[0];
    out[1] = pt[1] + t * dir[1];
    out[2] = pt[2] + t * dir[2];
    return [out, t];
}

function init() {
	classify.MMM = 63; // b00111111
	classify.MMP = 61; // b00111101
	classify.MPM = 55; // b00110111
	classify.MPP = 53; // b00110101
	classify.PMM = 31; // b00011111
	classify.PMP = 29; // b00011101
	classify.PPM = 23; // b00010111
	classify.PPP = 21; // b00010101
	classify.POO = 16; // b00010000
	classify.MOO = 48; // b00110000
	classify.OPO =  4; // b00000100
	classify.OMO = 12; // b00001100
	classify.OOP =  1; // b00000001
	classify.OOM =  3; // b00000011
	classify.OMM = 15; // b00001111
	classify.OMP = 13; // b00001101
	classify.OPM =  7; // b00000111
	classify.OPP =  5; // b00000101
	classify.MOM = 51; // b00110011
	classify.MOP = 49; // b00110001
	classify.POM = 19; // b00010011
	classify.POP = 17; // b00010001
	classify.MMO = 60; // b00111100
	classify.MPO = 52; // b00110100
	classify.PMO = 28; // b00011100
	classify.PPO = 20; // b00010100
	
	tests[classify.MMM] = function testMMM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[1] < lb[1] ||
	          ro[2] < lb[2] ||
	          ray.jbyi * lb[0] - ub[1] + ray.cxy > 0 ||
	          ray.ibyj * lb[1] - ub[0] + ray.cyx > 0 ||
	          ray.jbyk * lb[2] - ub[1] + ray.czy > 0 ||
	          ray.kbyj * lb[1] - ub[2] + ray.cyz > 0 ||
	          ray.kbyi * lb[0] - ub[2] + ray.cxz > 0 ||
	          ray.ibyk * lb[2] - ub[0] + ray.czx > 0);
	};
	tests[classify.MMP] = function testMMP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[1] < lb[1] ||
	          ro[2] > ub[2] ||
	          ray.jbyi * lb[0] - ub[1] + ray.cxy > 0 ||
	          ray.ibyj * lb[1] - ub[0] + ray.cyx > 0 ||
	          ray.jbyk * ub[2] - ub[1] + ray.czy > 0 ||
	          ray.kbyj * lb[1] - lb[2] + ray.cyz < 0 ||
	          ray.kbyi * lb[0] - lb[2] + ray.cxz < 0 ||
	          ray.ibyk * ub[2] - ub[0] + ray.czx > 0);
	};
	tests[classify.MPM] = function testMPM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[1] > ub[1] ||
	          ro[2] < lb[2] ||
	          ray.jbyi * lb[0] - lb[1] + ray.cxy < 0 ||
	          ray.ibyj * ub[1] - ub[0] + ray.cyx > 0 ||
	          ray.jbyk * lb[2] - lb[1] + ray.czy < 0 ||
	          ray.kbyj * ub[1] - ub[2] + ray.cyz > 0 ||
	          ray.kbyi * lb[0] - ub[2] + ray.cxz > 0 ||
	          ray.ibyk * lb[2] - ub[0] + ray.czx > 0);
	};
	tests[classify.MPP] = function testMPP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[1] > ub[1] ||
	          ro[2] > ub[2] ||
	          ray.jbyi * lb[0] - lb[1] + ray.cxy < 0 ||
	          ray.ibyj * ub[1] - ub[0] + ray.cyx > 0 ||
	          ray.jbyk * ub[2] - lb[1] + ray.czy < 0 ||
	          ray.kbyj * ub[1] - lb[2] + ray.cyz < 0 ||
	          ray.kbyi * lb[0] - lb[2] + ray.cxz < 0 ||
	          ray.ibyk * ub[2] - ub[0] + ray.czx > 0);
	};
	tests[classify.PMM] = function testPMM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] > ub[0] ||
	          ro[1] < lb[1] ||
	          ro[2] < lb[2] ||
	          ray.jbyi * ub[0] - ub[1] + ray.cxy > 0 ||
	          ray.ibyj * lb[1] - lb[0] + ray.cyx < 0 ||
	          ray.jbyk * lb[2] - ub[1] + ray.czy > 0 ||
	          ray.kbyj * lb[1] - ub[2] + ray.cyz > 0 ||
	          ray.kbyi * ub[0] - ub[2] + ray.cxz > 0 ||
	          ray.ibyk * lb[2] - lb[0] + ray.czx < 0);
	};
	tests[classify.PMP] = function testPMP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] > ub[0] ||
	          ro[1] < lb[1] ||
	          ro[2] > ub[2] ||
	          ray.jbyi * ub[0] - ub[1] + ray.cxy > 0 ||
	          ray.ibyj * lb[1] - lb[0] + ray.cyx < 0 ||
	          ray.jbyk * ub[2] - ub[1] + ray.czy > 0 ||
	          ray.kbyj * lb[1] - lb[2] + ray.cyz < 0 ||
	          ray.kbyi * ub[0] - lb[2] + ray.cxz < 0 ||
	          ray.ibyk * ub[2] - lb[0] + ray.czx < 0);
	};
	tests[classify.PPM] = function testPPM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] > ub[0] ||
	          ro[1] > ub[1] ||
	          ro[2] < lb[2] ||
	          ray.jbyi * ub[0] - lb[1] + ray.cxy < 0 ||
	          ray.ibyj * ub[1] - lb[0] + ray.cyx < 0 ||
	          ray.jbyk * lb[2] - lb[1] + ray.czy < 0 ||
	          ray.kbyj * ub[1] - ub[2] + ray.cyz > 0 ||
	          ray.kbyi * ub[0] - ub[2] + ray.cxz > 0 ||
	          ray.ibyk * lb[2] - lb[0] + ray.czx < 0);
	};
	tests[classify.PPP] = function testPPP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] > ub[0] ||
	          ro[1] > ub[1] ||
	          ro[2] > ub[2] ||
	          ray.jbyi * ub[0] - lb[1] + ray.cxy < 0 ||
	          ray.ibyj * ub[1] - lb[0] + ray.cyx < 0 ||
	          ray.jbyk * ub[2] - lb[1] + ray.czy < 0 ||
	          ray.kbyj * ub[1] - lb[2] + ray.cyz < 0 ||
	          ray.kbyi * ub[0] - lb[2] + ray.cxz < 0 ||
	          ray.ibyk * ub[2] - lb[0] + ray.czx < 0);
	};
	tests[classify.POO] = function testPOO(ray, lb, ub) {
	  var ro = ray.ro;
	  var ro1 = ro[1];
	  var ro2 = ro[2];
	
	  return !(ro[0] > ub[0] ||
	          ro1 < lb[1] ||
	          ro1 > ub[1] ||
	          ro2 < lb[2] ||
	          ro2 > ub[2]);
	};
	tests[classify.MOO] = function testMOO(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[1] < lb[1] ||
	          ro[1] > ub[1] ||
	          ro[2] < lb[2] ||
	          ro[2] > ub[2]);
	};
	tests[classify.OPO] = function testOPO(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[1] > ub[1] ||
	          ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[2] < lb[2] ||
	          ro[2] > ub[2]);
	};
	tests[classify.OMO] = function testOMO(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[1] < lb[1] ||
	          ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[2] < lb[2] ||
	          ro[2] > ub[2]);
	};
	tests[classify.OOP] = function testOOP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[2] > ub[2] ||
	          ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[1] < lb[1] ||
	          ro[1] > ub[1]);
	};
	tests[classify.OOM] = function testOOM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[2] < lb[2] ||
	          ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[1] < lb[1] ||
	          ro[1] > ub[1]);
	};
	tests[classify.OMM] = function testOMM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[1] < lb[1] ||
	          ro[2] < lb[2] ||
	          ray.jbyk * lb[2] - ub[1] + ray.czy > 0 ||
	          ray.kbyj * lb[1] - ub[2] + ray.cyz > 0);
	};
	tests[classify.OMP] = function testOMP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[1] < lb[1] ||
	          ro[2] > ub[2] ||
	          ray.jbyk * ub[2] - ub[1] + ray.czy > 0 ||
	          ray.kbyj * lb[1] - lb[2] + ray.cyz < 0);
	};
	tests[classify.OPM] = function testOPM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[1] > ub[1] ||
	          ro[2] < lb[2] ||
	          ray.jbyk * lb[2] - lb[1] + ray.czy < 0 ||
	          ray.kbyj * ub[1] - ub[2] + ray.cyz > 0);
	};
	tests[classify.OPP] = function testOPP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[0] < lb[0] ||
	          ro[0] > ub[0] ||
	          ro[1] > ub[1] ||
	          ro[2] > ub[2] ||
	          ray.jbyk * ub[2] - lb[1] + ray.czy < 0 ||
	          ray.kbyj * ub[1] - lb[2] + ray.cyz < 0);
	};
	tests[classify.MOM] = function testMOM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[1] < lb[1] ||
	          ro[1] > ub[1] ||
	          ro[0] < lb[0] ||
	          ro[2] < lb[2] ||
	          ray.kbyi * lb[0] - ub[2] + ray.cxz > 0 ||
	          ray.ibyk * lb[2] - ub[0] + ray.czx > 0);
	};
	tests[classify.MOP] = function testMOP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[1] < lb[1] ||
	          ro[1] > ub[1] ||
	          ro[0] < lb[0] ||
	          ro[2] > ub[2] ||
	          ray.kbyi * lb[0] - lb[2] + ray.cxz < 0 ||
	          ray.ibyk * ub[2] - ub[0] + ray.czx > 0);
	};
	tests[classify.POM] = function testPOM(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[1] < lb[1] ||
	          ro[1] > ub[1] ||
	          ro[0] > ub[0] ||
	          ro[2] < lb[2] ||
	          ray.kbyi * ub[0] - ub[2] + ray.cxz > 0 ||
	          ray.ibyk * lb[2] - lb[0] + ray.czx < 0);
	};
	tests[classify.POP] = function testPOP(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[1] < lb[1] ||
	          ro[1] > ub[1] ||
	          ro[0] > ub[0] ||
	          ro[2] > ub[2] ||
	          ray.kbyi * ub[0] - lb[2] + ray.cxz < 0 ||
	          ray.ibyk * ub[2] - lb[0] + ray.czx < 0);
	};
	tests[classify.MMO] = function testMMO(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[2] < lb[2] ||
	          ro[2] > ub[2] ||
	          ro[0] < lb[0] ||
	          ro[1] < lb[1] ||
	          ray.jbyi * lb[0] - ub[1] + ray.cxy > 0 ||
	          ray.ibyj * lb[1] - ub[0] + ray.cyx > 0);
	};
	tests[classify.MPO] = function testMPO(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[2] < lb[2] ||
	          ro[2] > ub[2] ||
	          ro[0] < lb[0] ||
	          ro[1] > ub[1] ||
	          ray.jbyi * lb[0] - lb[1] + ray.cxy < 0 ||
	          ray.ibyj * ub[1] - ub[0] + ray.cyx > 0);
	};
	tests[classify.PMO] = function testPMO(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[2] < lb[2] ||
	          ro[2] > ub[2] ||
	          ro[0] > ub[0] ||
	          ro[1] < lb[1] ||
	          ray.jbyi * ub[0] - ub[1] + ray.cxy > 0 ||
	          ray.ibyj * lb[1] - lb[0] + ray.cyx < 0);
	};
	tests[classify.PPO] = function testPPO(ray, lb, ub) {
	  var ro = ray.ro;
	
	  return !(ro[2] < lb[2] ||
	          ro[2] > ub[2] ||
	          ro[0] > ub[0] ||
	          ro[1] > ub[1] ||
	          ray.jbyi * ub[0] - lb[1] + ray.cxy < 0 ||
	          ray.ibyj * ub[1] - lb[0] + ray.cyx < 0);
	};
}

function rayIntersectsAABB(ray, aabb) {
  var t = tests[ray.classification];
  return (t && t(ray, aabb[0].point, aabb[1].point));
}

function rayIntersectsMeshes(ray, meshes, aabbs) {
	var intersections = [], distance = Infinity, triangle, intersection;
	
	meshes.forEach( (mesh,i) => {
		if (!aabbs[i] || rayIntersectsAABB(ray,aabbs[i])) {
			for (let face of mesh.faces) {
				triangle = [ mesh.vertices[face[0]], mesh.vertices[face[1]], mesh.vertices[face[2]] ];
				intersection = triangleTest([], ray.ro, ray.rd, triangle);
				if (intersection !== null) {
					intersections.push(intersection[0]);
					if (intersection[1] < distance) distance = intersection[1];
				}
			}
		}
	});
	
	return { intersections: intersections, closestDistance: distance };
}